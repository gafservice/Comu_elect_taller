# -*- coding: utf-8 -*-
"""TallerComu_P2_TX.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XgNY5isrL2oIehUcX_0jKJeKvp2eKc0h
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import wavfile
from scipy.signal import hilbert, butter, lfilter, resample
from IPython.display import Audio
import os

"""**Entradas**"""

# --- Cargar audio WAV ---
# --- Primer audio ---
fs_orig, audio_orig = wavfile.read("audio_mono.wav")
audio_orig = audio_orig.astype(np.float32)

# Define the frecuencia de muestreo y duracion.
fs = 120000           # Frecuencia de muestreo.
duracion = 5           # Duración en segundos.
N = int(fs * duracion) # Número de muestras para la señal remuestreada.

# Reajusta la frecuencia de muestreo y duracion del audio.
audio = resample(audio_orig, N)

audio /= np.max(np.abs(audio)) # Normaliza el audio
t = np.arange(N) / fs # Vector de tiempo para la señal remuestreada.

## FFT del audio resampleado.
# Calculate FFT frequencies based on the new N and fs
f = np.fft.fftfreq(N, 1/fs)
audio_fft = np.abs(np.fft.fft(audio))
#Conversion del espectro a dB.
audio_fft_db = 20 * np.log10(audio_fft + 1e-9)

# Graficas del primer audio original.
plt.figure(figsize=(20, 16))

# Audio de entrada en el dominio del tiempo.
plt.subplot(2, 1, 1)
plt.plot(t, audio)
plt.title("Gráfica del audio original")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")
plt.grid()

# Espectro del audio de entrada.
plt.subplot(2, 1, 2)
plt.plot(f[:N//2], audio_fft_db[:N//2])
plt.title("Espectro del audio original")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion del audio original.
Audio(audio, rate=fs)

# --- Cargar audio WAV ---
# --- Segundo audio ---
fs_orig2, audio_orig2 = wavfile.read("Tone_1kHz.wav")
audio_orig2 = audio_orig2.astype(np.float32)

# Define the frecuencia de muestreo y duracion.
fs2 = 120000           # Frecuencia de muestreo.
duracion2 = 5           # Duración en segundos.
N2 = int(fs2 * duracion2) # Número de muestras para la señal resampleada.

# Reajusta la frecuencia de muestreo y duracion del audio.
audio2 = resample(audio_orig2, N2)

audio2 /= np.max(np.abs(audio2)) # Normaliza el audio
t2 = np.arange(N) / fs2 # Vector de tiempo para la señal resampleada.

## FFT del audio resampleado.
# Calculate FFT frequencies based on the new N and fs
f2 = np.fft.fftfreq(N2, 1/fs2)
audio_fft2 = np.abs(np.fft.fft(audio2))
#Conversion del espectro a dB.
audio_fft_db2 = 20 * np.log10(audio_fft2 + 1e-9)

# Graficar segundo audio original.
plt.figure(figsize=(20, 16))

# Audio de entrada en el dominio del tiempo.
plt.subplot(2, 1, 1)
plt.plot(t, audio2)
plt.title("Gráfica del audio original")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")
plt.grid()

# Espectro del audio de entrada.
plt.subplot(2, 1, 2)
plt.plot(f[:N//2], audio_fft_db2[:N//2])
plt.title("Espectro del audio original")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion del segundo audio original.
Audio(audio2, rate=fs2)

"""**Modulacion**"""

# --- Modulación SSB ---
fc = 10000  # Frecuencia portadora.

carrier_cos = np.cos(2*np.pi*fc*t)
carrier_sin = np.sin(2*np.pi*fc*t)

#señal analitica (transformada de Hilbert).
analytic = np.imag(hilbert(audio))

#Modulacion SSB-SC.
ssb_sc_lsb = np.real(audio * carrier_cos + analytic * carrier_sin) # LSB
ssb_sc_usb = np.real(audio * carrier_cos - analytic * carrier_sin) # USB
#FFT de la señal SSB-SC.
ssb_sc_lsb_fft = np.abs(np.fft.fft(ssb_sc_lsb))
ssb_sc_usb_fft = np.abs(np.fft.fft(ssb_sc_usb))
#Conversion del espectro a dB.
ssb_sc_lsb_fft_db = 20 * np.log10(ssb_sc_lsb_fft)
ssb_sc_usb_fft_db = 20 * np.log10(ssb_sc_usb_fft)

#Modulacion SSB-FC.
ssb_fc_lsb = np.real(4 * carrier_cos + ssb_sc_lsb) # LSB, Ac = 4
ssb_fc_usb = np.real(4 * carrier_cos + ssb_sc_usb) # USB, Ac = 4
#FFT de la señal SSB-FC.
ssb_fc_lsb_fft = np.abs(np.fft.fft(ssb_fc_lsb))
ssb_fc_usb_fft = np.abs(np.fft.fft(ssb_fc_usb))
#Conversion del espectro a dB.
ssb_fc_lsb_fft_db = 20 * np.log10(ssb_fc_lsb_fft)
ssb_fc_usb_fft_db = 20 * np.log10(ssb_fc_usb_fft)

#Señal analitica del segundo audio.
analytic2 = np.imag(hilbert(audio2))

#Modulacion ISB.
isb_usb = np.real(audio * carrier_cos - analytic * carrier_sin)
isb_lsb = np.real(audio2 * carrier_cos + analytic2 * carrier_sin)
isb = isb_usb + isb_lsb
#FFT de la señal ISB.
isb_fft = np.abs(np.fft.fft(isb))
#conversion del espectro a dB.
isb_fft_db = 20 * np.log10(isb_fft)

# Guardar señal modulada.
np.save("ssb_modulada.npy", ssb_sc_lsb)

# --- Definir rango de frecuencia deseado ---
#f_pos = f[:N // 2]               # Solo parte positiva de la frecuencia
#ssb_fft_pos = ssb_fft[:N // 2]   # Magnitud correspondiente

f_min = 0
f_max = 100000  # Rango deseado: hasta 100 kHz
mask = (f >= f_min) & (f <= f_max)

# Graficar.
plt.figure(figsize=(20, 16))

#Espectro de la modulacion SSB-SC-USB.
plt.subplot(5, 1, 1)
plt.plot(f[mask], ssb_sc_usb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-USB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion SSB-SC-LSB.
plt.subplot(5, 1, 2)
plt.plot(f[mask], ssb_sc_lsb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-LSB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion SSB-FC-USB.
plt.subplot(5, 1, 3)
plt.plot(f[mask], ssb_fc_usb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-USB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion SSB-FC-LSB.
plt.subplot(5, 1, 4)
plt.plot(f[mask], ssb_fc_lsb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-LSB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion ISB.
plt.subplot(5, 1, 5)
plt.plot(f[mask], isb_fft_db[mask])
plt.title("Espectro de la modulacion ISB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion del audio modulado.
Audio(ssb_fc_usb, rate=fs)

"""**Transmision por parlante**"""

# Se define el tipo de modulacion a transmitir.
ssb = ssb_fc_usb

# === Tonos de inicio y fin ===
def tono(frecuencia, duracion):
    t = np.arange(int(fs * duracion)) / fs
    return 0.8 * np.sin(2 * np.pi * frecuencia * t)

tono_inicio = tono(10000, 0.7)
tono_final = tono(3000, 0.5)
retardo = np.zeros(int(0.2 * fs))  # 0.2 s de silencio

# === Señal final: retardo + tono de inicio + ssb + tono de fin ===
senal_tx = np.concatenate((retardo, tono_inicio, ssb, tono_final))

# Create a time vector for senal_tx
t_tx = np.arange(len(senal_tx)) / fs

# FFT de la señal TX.
senal_tx_fft = np.abs(np.fft.fft(senal_tx))
senal_tx_fft_db = 20 * np.log10(senal_tx_fft)

# For the FFT plot, you also need the correct frequency vector for senal_tx
# Calculate FFT frequencies based on the length of senal_tx
f_tx = np.fft.fftfreq(len(senal_tx), 1/fs)

# Visualizacion.
plt.figure(figsize=(20, 16))

# Audio de entrada en el dominio del tiempo.
plt.subplot(2, 1, 1)
plt.plot(t_tx, senal_tx)
plt.title("Gráfica del audio original")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")
plt.grid()

# Espectro del audio de entrada.
plt.subplot(2, 1, 2)
plt.plot(f_tx[:N//2], senal_tx_fft_db[:N//2])
plt.title("Espectro del audio original")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion de la señal.
Audio(senal_tx, rate=fs)
