# -*- coding: utf-8 -*-
"""TallerComu_P2_SSB_ISB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11GVfYCXHFT5f7wUa7s1IoC5QEEXKxlSp

**Modulador**
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import wavfile
from scipy.signal import hilbert, butter, lfilter, resample
from IPython.display import Audio
import os

# --- Cargar audio WAV ---
# --- Primer audio ---
fs_orig, audio_orig = wavfile.read("Conference.wav")
audio_orig = audio_orig.astype(np.float32)

# Define the frecuencia de muestreo y duracion.
fs = 120000           # Frecuencia de muestreo.
duracion = 4           # Duración en segundos.
N = int(fs * duracion) # Número de muestras para la señal remuestreada.

# Reajusta la frecuencia de muestreo y duracion del audio.
audio = resample(audio_orig, N)


audio /= np.max(np.abs(audio)) # Normaliza el audio
t = np.arange(N) / fs # Vector de tiempo para la señal remuestreada.

## FFT del audio resampleado.
# Calculate FFT frequencies based on the new N and fs
f = np.fft.fftfreq(N, 1/fs)
audio_fft = np.abs(np.fft.fft(audio))
#Conversion del espectro a dB.
audio_fft_db = 20 * np.log10(audio_fft + 1e-9)

# Graficas del primer audio original.
plt.figure(figsize=(20, 16))

# Audio de entrada en el dominio del tiempo.
plt.subplot(2, 1, 1)
plt.plot(t, audio)
plt.title("Gráfica del audio original")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")
plt.grid()

# Espectro del audio de entrada.
plt.subplot(2, 1, 2)
plt.plot(f[:N//2], audio_fft_db[:N//2])
plt.title("Espectro del audio original")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion del audio original.
Audio(audio, rate=fs)

# --- Cargar audio WAV ---
# --- Segundo audio ---
fs_orig2, audio_orig2 = wavfile.read("Tone_1kHz.wav")
audio_orig2 = audio_orig2.astype(np.float32)

# Define the frecuencia de muestreo y duracion.
fs2 = 120000           # Frecuencia de muestreo.
duracion2 = 4           # Duración en segundos.
N2 = int(fs2 * duracion2) # Número de muestras para la señal resampleada.

# Reajusta la frecuencia de muestreo y duracion del audio.
audio2 = resample(audio_orig2, N2)

audio2 /= np.max(np.abs(audio2)) # Normaliza el audio
t2 = np.arange(N) / fs2 # Vector de tiempo para la señal resampleada.

## FFT del audio resampleado.
# Calculate FFT frequencies based on the new N and fs
f2 = np.fft.fftfreq(N2, 1/fs2)
audio_fft2 = np.abs(np.fft.fft(audio2))
#Conversion del espectro a dB.
audio_fft_db2 = 20 * np.log10(audio_fft2 + 1e-9)

# Graficar segundo audio original.
plt.figure(figsize=(20, 16))

# Audio de entrada en el dominio del tiempo.
plt.subplot(2, 1, 1)
plt.plot(t, audio2)
plt.title("Gráfica del audio original")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")
plt.grid()

# Espectro del audio de entrada.
plt.subplot(2, 1, 2)
plt.plot(f[:N//2], audio_fft_db2[:N//2])
plt.title("Espectro del audio original")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion del segundo audio original.
Audio(audio2, rate=fs2)

# --- Modulación SSB ---
fc = 40000  # Frecuencia portadora.

carrier_cos = np.cos(2*np.pi*fc*t)
carrier_sin = np.sin(2*np.pi*fc*t)

#señal analitica (transformada de Hilbert).
analytic = np.imag(hilbert(audio))

#Modulacion SSB-SC.
ssb_sc_lsb = np.real(audio * carrier_cos + analytic * carrier_sin) # LSB
ssb_sc_usb = np.real(audio * carrier_cos - analytic * carrier_sin) # USB
#FFT de la señal SSB-SC.
ssb_sc_lsb_fft = np.abs(np.fft.fft(ssb_sc_lsb))
ssb_sc_usb_fft = np.abs(np.fft.fft(ssb_sc_usb))
#Conversion del espectro a dB.
ssb_sc_lsb_fft_db = 20 * np.log10(ssb_sc_lsb_fft)
ssb_sc_usb_fft_db = 20 * np.log10(ssb_sc_usb_fft)

#Modulacion SSB-FC.
ssb_fc_lsb = np.real(4 * carrier_cos + ssb_sc_lsb) # LSB, Ac = 4
ssb_fc_usb = np.real(4 * carrier_cos + ssb_sc_usb) # USB, Ac = 4
#FFT de la señal SSB-FC.
ssb_fc_lsb_fft = np.abs(np.fft.fft(ssb_fc_lsb))
ssb_fc_usb_fft = np.abs(np.fft.fft(ssb_fc_usb))
#Conversion del espectro a dB.
ssb_fc_lsb_fft_db = 20 * np.log10(ssb_fc_lsb_fft)
ssb_fc_usb_fft_db = 20 * np.log10(ssb_fc_usb_fft)

#Señal analitica del segundo audio.
analytic2 = np.imag(hilbert(audio2))

#Modulacion ISB.
isb_usb = np.real(audio * carrier_cos - analytic * carrier_sin)
isb_lsb = np.real(audio2 * carrier_cos + analytic2 * carrier_sin)
#FFT de la señal ISB.
isb_fft_usb = np.abs(np.fft.fft(isb_usb))
isb_fft_lsb = np.abs(np.fft.fft(isb_lsb))
#conversion del espectro a dB.
isb_fft_db_usb = 20 * np.log10(isb_fft_usb)
isb_fft_db_lsb = 20 * np.log10(isb_fft_lsb)

# Guardar señal modulada.
np.save("ssb_modulada.npy", ssb_sc_lsb)

# --- Definir rango de frecuencia deseado ---
#f_pos = f[:N // 2]               # Solo parte positiva de la frecuencia
#ssb_fft_pos = ssb_fft[:N // 2]   # Magnitud correspondiente

f_min = 0
f_max = 100000  # Rango deseado: hasta 100 kHz
mask = (f >= f_min) & (f <= f_max)

# Graficar.
plt.figure(figsize=(20, 16))

#Espectro de la modulacion SSB-SC-USB.
plt.subplot(5, 1, 1)
plt.plot(f[mask], ssb_sc_usb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-USB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion SSB-SC-LSB.
plt.subplot(5, 1, 2)
plt.plot(f[mask], ssb_sc_lsb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-LSB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion SSB-FC-USB.
plt.subplot(5, 1, 3)
plt.plot(f[mask], ssb_fc_usb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-USB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion SSB-FC-LSB.
plt.subplot(5, 1, 4)
plt.plot(f[mask], ssb_fc_lsb_fft_db[mask])
plt.title("Espectro de la modulacion SSB-SC-LSB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

#Espectro de la modulacion ISB.
plt.subplot(5, 1, 5)
plt.plot(f[mask], isb_fft_db_usb[mask])
plt.title("Espectro de la modulacion ISB")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion del audio modulado.
Audio(ssb_fc_usb, rate=fs)

"""**Canal**"""

# Error de fase.
phi = np.pi

# Error de frecuencia.
deltaf = 0.01 * fc

"""**Demodulacion**"""

# Filtro pasa bajas Butterworth.
def butter_lowpass_filter(data, cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low')
    y = lfilter(b, a, data)
    return y

def ssb_demodulate(signal, fc, fs, sideband='usb', is_fc=False):
    """
    Demodula una señal SSB.

    Parámetros:
    - signal: señal modulada (SSB-SC o SSB-FC)
    - fc: frecuencia de la portadora
    - fs: frecuencia de muestreo
    - sideband: 'usb' o 'lsb'
    - is_fc: True si es SSB-FC, False si es SSB-SC

    Retorna:
    - Señal demodulada (audio base)
    """

    t = np.arange(len(signal)) / fs

    # Si es SSB-FC, primero eliminar la portadora (puedes usar un filtro notch o restarla si se conoce)
    if is_fc:
        # Estimar y remover la portadora (asumimos Ac=1)
        carrier = np.cos(2 * np.pi * fc * t)
        signal = signal - carrier

    # Demodulación coherente
    if sideband == 'usb':
        demodulated = signal * np.cos(2 * np.pi * (fc + deltaf) * t + phi)
    elif sideband == 'lsb':
        demodulated = signal * np.cos(2 * np.pi * (fc + deltaf) * t + phi)
    else:
        raise ValueError("sideband debe ser 'usb' o 'lsb'")

    # Filtro pasa bajos para recuperar el mensaje
    cutoff = 20000  # Frecuencia de corte para filtro pasa bajos
    recovered = butter_lowpass_filter(demodulated, cutoff=cutoff, fs=fs, order=6)

    return recovered

def envelope_demodulation(signal, fs, cutoff=20000):
    """
    Demodulación por detección de envolvente con filtrado pasa bajos.
    """
    # Obtener la envolvente con Hilbert
    analytic_signal = hilbert(signal)
    envelope = np.abs(analytic_signal)

    # Filtro pasa bajas adecuado
    envelope_filtered = butter_lowpass_filter(envelope, cutoff=cutoff, fs=fs, order=10)

    envelope_filtered = envelope_filtered - np.mean(envelope_filtered)
    envelope_filtered = envelope_filtered / np.max(np.abs(envelope_filtered))

    return envelope_filtered

# Demodulación coherente.
audio_rec_sc_usb = ssb_demodulate(ssb_sc_usb, fc, fs, sideband='usb', is_fc=False)
audio_rec_sc_lsb = ssb_demodulate(ssb_sc_lsb, fc, fs, sideband='lsb', is_fc=False)

audio_rec_isb_usb = ssb_demodulate(isb_usb, fc, fs, sideband='usb', is_fc=False)
audio_rec_isb_lsb = ssb_demodulate(isb_lsb, fc, fs, sideband='lsb', is_fc=False)

# Demodulacion por deteccion de envolvente.
audio_rec_fc_usb = envelope_demodulation(ssb_fc_usb, fs)
audio_rec_fc_lsb = envelope_demodulation(ssb_fc_lsb, fs)

# Eleccion del tipo de demodulacion.
demodulada = audio_rec_isb_lsb
demodulada_fft = np.abs(np.fft.fft(demodulada))
demodulada_fft_db = 20 * np.log10(demodulada_fft)

# Graficar.
plt.figure(figsize=(20, 16))

# Audio de entrada en el dominio del tiempo.
plt.subplot(2, 1, 1)
plt.plot(t, demodulada)
plt.title("Gráfica del audio demodulado en el tiempo")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")
plt.grid()

# Espectro del audio de entrada.
plt.subplot(2, 1, 2)
plt.plot(f[:N//2], demodulada_fft_db[:N//2])
plt.title("Espectro del audio demodulado")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (dB)")
plt.grid()

plt.tight_layout()
plt.show()

# Reproduccion del audio demodulado.
Audio(demodulada, rate=fs)